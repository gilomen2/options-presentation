import { Notes, Image } from "mdx-deck"
import { CodeSurfer, CodeSurferColumns, Step } from "code-surfer"
import { oceanicNext } from "@code-surfer/themes"
import { AboutMe } from "./slide-layouts/about-me"

export const theme = oceanicNext

# Options All the Way Down

---

<AboutMe />

---

## What are we doing?

<Notes>
Favor specializes in "Anything Delivered" meaning that you can get a burger from HopDoddy, Benedryl from Walgreens, or even ask a runner to go to your house when you're out of town and bring your trash and recycling cans in from the street so your HOA doesn't get mad at you.

Because of the freeform nature of our service, we've traditionally had a very free-form way of ordering.

However, that can sometimes make customizing items difficult for the customer and hard to understand for the runner.

Lately, we've been exploring ways to build item customization that can alleviate some of those issues for places with known menus, where customization is an important part of the menu.

So, how are we doing that?
</Notes>

---

## Creating Infinitely Nested Option Select Lists with React

<Image src='/static/options-list.png' style={{ width: '67%', backgroundSize: 'contain' }}></Image>

---

<CodeSurfer>

```json file=./examples/exampleItemStructure.json
```

```json 2:4 file=./examples/exampleItemStructure.json
```

```json 5:11 file=./examples/exampleItemStructure.json
```

```json 13:15 file=./examples/exampleItemStructure.json
```

</CodeSurfer>

<Notes>
Recursive structure of a menu item.

An item has an id and name and an array of option groups. Each option group is an object that has an array of options. These are the options that are actually selectable.

Options can also have their own option groups, and so on.
</Notes>

---

<CodeSurfer>

```jsx 1 1:11 file=./examples/App.js title="Set Up Our Menu"
```

```jsx 2 13:39 file=./examples/App.js title="Set Up Our Menu"
```

```jsx 3 14 file=./examples/App.js title="Set Up Our Menu"
```

</CodeSurfer>


<Notes>
We're creating our App which will map over an array of menuItems and display an instance of a MenuItem component for each.

!!NEXT!!

So, here's our MenuItem component. It takes in an item prop.

!!NEXT!!

We're creating a state variable called "currentSelections" which will represent what options are selected for our menuItem.
</Notes>

---

<CodeSurferColumns>

<Step>

```jsx 14 file=./examples/App.js
```

```json 1:11 file=./examples/exampleItemPizza.json
```

</Step>

<Step>

```jsx 1 14 file=./examples/App.js
```

```json
[
  {
    "id": "d317a2a8-b294-48ab-8a04-140cea3a04c4",
    "name": "Select a Size",
    "options": []
  }
]
```

</Step>


</CodeSurferColumns>

<Notes>
We're giving it an initial state that represents anything that is selected by default for our top-level option groups. This item only has one top-level option group called "Select a Size" and nothing is selected by default, so our currentSelections looks like this.
</Notes>

---

<CodeSurfer>

```jsx 1 16:25 file=./examples/App.js
```

```jsx 2 17:22 file=./examples/App.js
```

```jsx 3 24 file=./examples/App.js
```

</CodeSurfer>

<Notes>
Next, we have our handler for updating the state of the current selections, which will get passed down to our child components.

It's going to take in newOptionGroupSelections, which will represent the selections of the option group that has had a change made to its selections.

!!NEXT!!

Then we're going to create a new array from the currentSelections with the changed optionGroup replacing the matching one from the currentSelections.

!!NEXT!!

Finally, we'll update the state to replace the new selections.
</Notes>

---

<CodeSurfer>

```jsx 4 27:39 file=./examples/App.js
```

</CodeSurfer>

<Notes>

Now let's look at the render.

We're displaying the item name, then we're going to map over the item's top-level option groups and display an OptionGroup component for each. We're passing in the individual optionGroup, which is the full data for the optionGroup from the menuItem. That represents all of the data that will be displayed for the optionGroup.

We're also passing in the currentOptionGroupSelections, which is the state of what is selected for the option group. We're using a helper function here to get the currentSelections for just the option group in question.

And then we're passing in our handler as an onChange prop.

</Notes>

---

<CodeSurfer>

```jsx 1 41:124 file=./examples/App.js
```

```jsx 2 87:123 file=./examples/App.js
```

```jsx 3 90 file=./examples/App.js
```

```jsx 4 95:101 file=./examples/App.js
```

```jsx 5 100 file=./examples/App.js
```

</CodeSurfer>

<Notes>
Next let's look at the part that is doing the heavy lifting -- the OptionGroup component.

!!NEXT!!

We're going to skip down to the render method first

!!NEXT!!

Each option group has an array of options.

!!NEXT!!

For each option we're going to render a selectable radio button or checkbox

!!NEXT!!

And for the input's onChange prop, we're going to pass in an anonymous function that calls a function named createNewOptionGroupSelections
</Notes>

---

<CodeSurfer>

```jsx 1 48:64 file=./examples/App.js
```

```jsx 2 49:51 file=./examples/App.js
```

```jsx 3 52:54 file=./examples/App.js
```

```jsx 4 56:60 file=./examples/App.js
```

```jsx 5 62 file=./examples/App.js
```

```jsx 6 16:25 file=./examples/App.js
```

</CodeSurfer>

<Notes>
Looking at that function...

!!NEXT!!

First we make copies of objects that we are going to modify.

!!NEXT!!

Then, if the changed option is selected, we get the default selections for its nested option_groups so that we can show them as selected as well

!!NEXT!!

If it's a radio button, we can replace the current selection with the new selection. If it's a checkbox, we first determine if the change is that it has become checked or unchecked. Then, If it is checked, we add the new selection to the current selections. If it isn't checked, we filter the current selections to only those that don't match the id of the changed option.

!!NEXT!!

Then, we call the onChange prop and pass in our newSelections. In the case of the top-level optionGroup, the function that was passed in as the onChange prop is...

!!NEXT!!

The handleSetSelections function from our MenuItem component. It will take in the newSelections for the optionGroup and replace that option group in our selections state.
</Notes>

---

<CodeSurfer>

```jsx 1 87:122 file=./examples/App.js
```

```jsx 2 106:115 file=./examples/App.js
```

```jsx 3 113 file=./examples/App.js
```

</CodeSurfer>

<Notes>

So, that takes care of selecting or deselecting a top-level option, but we still have render and handle selecting nest option groups, and this is where we get into some recursion.

!!NEXT!!

For each option in our optionGroup, if the option is selected, we want to display it's nested option groups. We do that by rendering the OptionGroup component from the render method of the OptionGroup component, hence the recursion.

For anyone whose not familiar with the term, recursion is the process a procedure goes through when one of the steps of the procedure involves invoking the procedure itself.

!!NEXT!!

Looks like we're going to get into an infinite loop by passing a function execution to the onChange prop, but actually, this is an example of using the functional programming concept of partial application
</Notes>

---

<CodeSurfer>

```jsx 1 65:84 file=./examples/App.js
```

```jsx 2 65 file=./examples/App.js
```

</CodeSurfer>

<Notes>

!!NEXT!!

</Notes>